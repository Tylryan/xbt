# XBT 0.2.0
XBT will be separated out into the language and the appliction. I think I will try to create an auto-compile-tool like CMake which uses XBTLang (for now) to decide it's next actions.

As of right now, XBT the application is 0% implemented and XBTLang is at version 0.1.0 working its way to 0.2.0.

## 0.2.0 Language Feature Goals
Below are some feature I'm thinking of implementing for 
### 0.2.0 Statement Enders
The new syntax for ending a statement will be the period instead of
the semicolon.
```enbf
/* New */
statement := expr '.' ;
/* Old */
statement := expr ';' ;
```
### 0.2.0 Keywords
In 0.1.0, some variables were treated like keywords. However, In 
0.2.0, they will be converted to keywords. Below is a syntax comparison as well as a list of said keywords.

```ebnf
/* New */
keyword := KEYWORD (STRING)+ ;
/* Old */
keyword := VAR (STRING)+ ;

/* New Keywords */
KEYWORD := "build_files"
           | "output_files"
           | "watch_files" ;

VAR := "$"IDENT ;
```

### 0.2.0 Rule Members
I would like to give the user the ability to access variables within each `rule`. Think `{"main": {"clean": "$ rm -rf /"}}`.
Below will be the syntax:
```ebnf
rule_member = RULE '::' VAR ;
```


### 0.2.0 Auto XBT
For something like a C project, you could create these files
automatically by searching through a directory, mapping the
unique file names (minus the extention) to a `rule`. In order
to do this, I'm going to need to implement a couple of things.

** 0.2.0 Global Scope**
In the "0.2.0 Code" section below, everything until the Main
rule is a global variable. I think they will make the output
`.xbt` files more uniform. Their syntax will be:
```ebnf
global_variable = '$'CAPITAL_IDENT '=' STRING ;
```

**0.2.0 xbt init and xbt.lock and xbt.settings**
TODO
**xbt clean**
TODO
**xbt compile**
TODO

## 0.2.0 Code
```
/* Can't get rid of the ';'. They are required
 * for knowing when to stop when assigning/declaring 
 * multiple values.
 * I could probably figure out how to change the syntax
 * but I think the semicolons look better than adding a list
 * structure.
 */
$MAIN   = "main"     .
$MAIN_C = "${MAIN}.c".
$MAIN_H = "${MAIN}.h".
$MAIN_O = "${MAIN}.o".

$HELPER   = "helper"     .
$HELPER_C = "${HELPER}.c".
$HELPER_H = "${HELPER}.h".
$HELPER_O = "${HELPER}.o".

rule  Main  {
    /* `bin` would be a keyword that would 
        * give this info */
    output_files: bin                        .
    build_files : $MAIN_C Helper::build_files.
    watch_files : $MAIN_H                    .
    clean       : bin Helper::clean          .

    $ gcc -o $output_files $build_files
}

rule Helper {
    output_files: $HELPER_O   .
    build_files : $HELPER_C   .
    watch_files : $HELPER_H   .
    clean       : output_files.

    $ gcc -o $output_files -c $build_files
}

/* This is the 'pseudo code' for how I would implement
    * `xbt clean`.
    * /
rule Clean {
    clean Main::clean.
}
```

# Draft Auto-XBT Idea
## 0.2.0 New Feature Descriptions
1. Change $build_files, et. al., to keywords with the following
   syntax: `build_files: "one.c" "two.c" ;`
2. Make rules act like structs in a way by allowing them to be
   referrenced like: `Animal::build_files` or `Rule::keyword` to
   generalize.
3. It would be neat to create a program that creates these files
   for every directory in a C project and climbs back up to the
   projects root and runs them all. These files are so repetetive for a C project, you could write a program to do it. For each directory, find your .h, .c, .o, etc files and
   create this file for them where only the constants need to change.
4. `xbt clean:` Think for c: Searches a directory and finds all
    the .c, .h. .o, etcs files and creates a rule for them like:

    1. Search directory.  `files == [ "main.c" "helper.c, "helper.h", "helper.o"]`
    2. Filter for unique names.  `filtered = files.unique()`

    3. Somehow know the entry file name. 
        - `xbt init`: have a `xbt.lock` file which defines `{"entry": "/path/to/main.c"}`.

    4. Remove the entry file from that list.

    5. Create a rule for each one of those unique
          elements.

    6.  Assuming we have a `xbt.lock` file that specfied that the entry point was main.c... `{"entry": "path/to/main.c" }`.
    - change `$keywords = VALUE` into `keywords : VALUE`. (E.g. $output_files -> output_files)
    - global scope/variables: Need to implement this.
    - `bin`: Provides paths to all binary outputs of the project.
             entry will be provided, but the  .lock file could
             contain more or something.
5. A user can provide a dictionary defining how to clean unknown
files types
```
{
    "clean" : { 
        "file-types" : {
            "h": "rm"
        }
    },
    "settings": {
        "remove-directories": false,
    }
}
```